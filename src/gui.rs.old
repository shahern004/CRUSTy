use eframe::egui;
use egui::{Ui, Color32, Button, RichText, Stroke, Rounding};
use std::path::{PathBuf, Path};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::time::{SystemTime, Duration};

// File status enum for the list-based design
#[derive(Debug, Clone, PartialEq)]
pub enum FileStatus {
    Pending,
    InProgress(f32), // Progress percentage (0.0 - 1.0)
    Completed,
    Failed,
}

// File entry struct for the list-based design
#[derive(Debug, Clone)]
pub struct FileEntry {
    pub path: PathBuf,
    pub status: FileStatus,
    pub result: Option<String>,
    pub error: Option<String>,
    pub timestamp: SystemTime,
    pub operation_type: FileOperationType,
}

// File operation type enum
#[derive(Debug, Clone, PartialEq)]
pub enum FileOperationType {
    Encrypt,
    Decrypt,
    None,
}

impl FileEntry {
    pub fn new(path: PathBuf, operation_type: FileOperationType) -> Self {
        FileEntry {
            path,
            status: FileStatus::Pending,
            result: None,
            error: None,
            timestamp: SystemTime::now(),
            operation_type,
        }
    }
    
    pub fn file_name(&self) -> String {
        self.path.file_name()
            .map(|name| name.to_string_lossy().to_string())
            .unwrap_or_else(|| "Unknown file".to_string())
    }
    
    pub fn set_progress(&mut self, progress: f32) {
        self.status = FileStatus::InProgress(progress);
    }
    
    pub fn set_completed(&mut self, result: String) {
        self.status = FileStatus::Completed;
        self.result = Some(result);
        self.timestamp = SystemTime::now();
    }
    
    pub fn set_failed(&mut self, error: String) {
        self.status = FileStatus::Failed;
        self.error = Some(error);
        self.timestamp = SystemTime::now();
    }
    
    pub fn status_text(&self) -> String {
        match &self.status {
            FileStatus::Pending => "Pending".to_string(),
            FileStatus::InProgress(progress) => format!("In Progress: {:.1}%", progress * 100.0),
            FileStatus::Completed => "Completed".to_string(),
            FileStatus::Failed => "Failed".to_string(),
        }
    }
    
    pub fn status_color(&self, theme: &AppTheme) -> Color32 {
        match &self.status {
            FileStatus::Pending => theme.text_secondary,
            FileStatus::InProgress(_) => theme.button_normal,
            FileStatus::Completed => theme.success,
            FileStatus::Failed => theme.error,
        }
    }
    
    pub fn elapsed_time(&self) -> Option<Duration> {
        SystemTime::now().duration_since(self.timestamp).ok()
    }
    
    pub fn elapsed_text(&self) -> String {
        if let Some(duration) = self.elapsed_time() {
            let seconds = duration.as_secs();
            if seconds < 60 {
                format!("{} seconds ago", seconds)
            } else if seconds < 3600 {
                format!("{} minutes ago", seconds / 60)
            } else {
                format!("{} hours ago", seconds / 3600)
            }
        } else {
            "Just now".to_string()
        }
    }
}

use crate::encryption::EncryptionKey;
use crate::logger::get_logger;
use crate::backend::{EmbeddedConfig, ConnectionType};
use crate::start_operation::FileOperation;
use crate::transfer_gui::{TransferState, TransferReceiveState};
use crate::split_key::TransferPackage;

// Define color theme for the application
pub struct AppTheme {
    pub background: Color32,
    pub accent: Color32,
    pub text_primary: Color32,
    pub text_secondary: Color32,
    pub button_text: Color32,  // New color for button text
    pub button_normal: Color32,
    pub button_hovered: Color32,
    pub button_active: Color32,
    pub error: Color32,
    pub success: Color32,
}

impl Default for AppTheme {
    fn default() -> Self {
        AppTheme {
            background: Color32::from_rgb(248, 248, 248), // Off-white background
            accent: Color32::from_rgb(255, 140, 0),       // Orange accent (#FF8C00)
            text_primary: Color32::from_rgb(20, 20, 20),  // Near black text
            text_secondary: Color32::from_rgb(100, 100, 100), // Gray text
            button_text: Color32::from_rgb(240, 240, 255), // Light text for buttons that's easier to read
            button_normal: Color32::from_rgb(30, 144, 255), // Blue buttons (#1E90FF)
            button_hovered: Color32::from_rgb(255, 140, 0), // Orange when hovered (#FF8C00)
            button_active: Color32::from_rgb(0, 84, 195), // Darker blue when clicked
            error: Color32::from_rgb(220, 50, 50),        // Red for errors
            success: Color32::from_rgb(50, 180, 50),      // Green for success
        }
    }
}

// Application state enum for different screens
pub enum AppState {
    Dashboard,  // New dashboard view
    Main,       // Original main screen (will be kept for backward compatibility)
    Encrypting,
    EncryptionWorkflow, // New horizontal workflow for encryption
    Decrypting,
    KeyManagement,
    SplitKeyManagement,
    TransferPreparation,
    TransferReceive,
    ViewLogs,
    About,
}

// Encryption workflow step enum for horizontal layout
#[derive(PartialEq, Clone)]
pub enum EncryptionWorkflowStep {
    Files,      // File selection step
    Keys,       // Key selection/creation step
    Options,    // Encryption options step
    Execute,    // Operation execution step
}

impl EncryptionWorkflowStep {
    // Get the next step in the workflow
    pub fn next(&self) -> Self {
        match self {
            EncryptionWorkflowStep::Files => EncryptionWorkflowStep::Keys,
            EncryptionWorkflowStep::Keys => EncryptionWorkflowStep::Options,
            EncryptionWorkflowStep::Options => EncryptionWorkflowStep::Execute,
            EncryptionWorkflowStep::Execute => EncryptionWorkflowStep::Execute, // Stay on execute step
        }
    }
    
    // Get the previous step in the workflow
    pub fn previous(&self) -> Self {
        match self {
            EncryptionWorkflowStep::Files => EncryptionWorkflowStep::Files, // Stay on files step
            EncryptionWorkflowStep::Keys => EncryptionWorkflowStep::Files,
            EncryptionWorkflowStep::Options => EncryptionWorkflowStep::Keys,
            EncryptionWorkflowStep::Execute => EncryptionWorkflowStep::Options,
        }
    }
    
    // Convert step to string for display
    pub fn to_string(&self) -> String {
        match self {
            EncryptionWorkflowStep::Files => "1. Files".to_string(),
            EncryptionWorkflowStep::Keys => "2. Keys".to_string(),
            EncryptionWorkflowStep::Options => "3. Options".to_string(),
            EncryptionWorkflowStep::Execute => "4. Execute".to_string(),
        }
    }
}


// Application structure
pub struct CrustyApp {
    pub state: AppState,
    pub theme: AppTheme,
    
    // Workflow tracking
    pub encryption_workflow_step: EncryptionWorkflowStep,
    pub encryption_workflow_complete: bool,
    
    // File paths
    pub selected_files: Vec<PathBuf>,
    pub output_dir: Option<PathBuf>,
    
    // File list for tracking operation history
    pub file_entries: Vec<FileEntry>,
    
    // Key management
    pub current_key: Option<EncryptionKey>,
    pub key_path: Option<PathBuf>,
    pub saved_keys: Vec<(String, EncryptionKey)>, // (key_name, key)
    pub new_key_name: String,
    
    // Recipient information
    pub recipient_email: String,
    pub use_recipient: bool,
    
    // Progress tracking
    pub operation: FileOperation,
    pub progress: Arc<Mutex<Vec<f32>>>,
    pub operation_results: Vec<String>,
    pub shared_results: Arc<Mutex<Vec<String>>>, // Shared results for thread communication
    
    // Status and errors
    pub status_message: String,
    pub error_message: String,
    pub last_status: Option<String>,
    pub last_error: Option<String>,
    
    // Flag for batch operation
    pub batch_mode: bool,
    
    // Embedded backend configuration
    pub use_embedded_backend: bool,
    pub embedded_config: Option<EmbeddedConfig>,
    pub embedded_connection_type: ConnectionType,
    pub embedded_device_id: String,
    pub embedded_parameters: HashMap<String, String>,
    
    // Transfer functionality
    pub transfer_package: Option<TransferPackage>,
    pub transfer_state: TransferState,
    pub transfer_receive_state: TransferReceiveState,
    pub transfer_share1: String,
    pub transfer_share2: String,
}

impl Default for CrustyApp {
    fn default() -> Self {
        CrustyApp {
            state: AppState::Dashboard,
            theme: AppTheme::default(),
            
            // Initialize workflow tracking
            encryption_workflow_step: EncryptionWorkflowStep::Files,
            encryption_workflow_complete: false,
            
            selected_files: Vec::new(),
            output_dir: None,
            
            // Initialize file list
            file_entries: Vec::new(),
            
            current_key: None,
            key_path: None,
            saved_keys: Vec::new(),
            new_key_name: String::new(),
            
            recipient_email: String::new(),
            use_recipient: false,
            
            operation: FileOperation::None,
            progress: Arc::new(Mutex::new(Vec::new())),
            operation_results: Vec::new(),
            shared_results: Arc::new(Mutex::new(Vec::new())),
            
            status_message: "Welcome to CRUSTy".to_string(),
            error_message: String::new(),
            last_status: None,
            last_error: None,
            
            batch_mode: false,
            
            use_embedded_backend: false,
            embedded_config: None,
            embedded_connection_type: ConnectionType::Usb,
            embedded_device_id: String::new(),
            embedded_parameters: HashMap::new(),
            
            transfer_package: None,
            transfer_state: TransferState::Initial,
            transfer_receive_state: TransferReceiveState::Initial,
            transfer_share1: String::new(),
            transfer_share2: String::new(),
        }
    }
}

impl eframe::App for CrustyApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Update operation results from shared results
        self.update_operation_results();
        
        // Check for any status or error messages set by UI callbacks
        if let Some(status) = self.last_status.take() {
            self.show_status(&status);
        }
        
        if let Some(error) = self.last_error.take() {
            self.show_error(&error);
        }
        
        let mut style = (*ctx.style()).clone();
        style.visuals.window_fill = self.theme.background;
        style.visuals.widgets.noninteractive.bg_fill = self.theme.background;
        style.visuals.widgets.inactive.bg_fill = self.theme.button_normal;
        style.visuals.widgets.hovered.bg_fill = self.theme.button_hovered;
        style.visuals.widgets.active.bg_fill = self.theme.button_active;
        style.visuals.widgets.inactive.fg_stroke = Stroke::new(1.0, self.theme.button_text);
        style.visuals.widgets.hovered.fg_stroke = Stroke::new(1.0, self.theme.button_text);
        style.visuals.widgets.active.fg_stroke = Stroke::new(1.0, self.theme.button_text);
        ctx.set_style(style);

        egui::CentralPanel::default().show(ctx, |ui| {
            ui.visuals_mut().override_text_color = Some(self.theme.text_primary);
            
            // App header
            ui.horizontal(|ui| {
                ui.heading(RichText::new("CRUSTy").color(self.theme.accent).size(24.0));
                ui.add_space(20.0);
                
                // Dashboard button (Home)
                if !matches!(self.state, AppState::Dashboard) {
                    if ui.add(Button::new(RichText::new("üè† Dashboard").color(self.theme.button_text))
                        .fill(self.theme.button_normal)
                        .rounding(Rounding::same(5.0))
                    ).clicked() {
                        self.state = AppState::Dashboard;
                        self.operation = FileOperation::None;
                    }
                }
                
                // Renamed from "Keys" to "Key Management"
                if ui.add(Button::new(RichText::new("üîë Key Management").color(self.theme.button_text))
                    .fill(self.theme.button_normal)
                    .rounding(Rounding::same(5.0))
                ).clicked() {
                    self.state = AppState::KeyManagement;
                }
                
                if ui.add(Button::new(RichText::new("üìã Logs").color(self.theme.button_text))
                    .fill(self.theme.button_normal)
                    .rounding(Rounding::same(5.0))
                ).clicked() {
                    self.state = AppState::ViewLogs;
                }
                
                if ui.add(Button::new(RichText::new("‚ÑπÔ∏è About").color(self.theme.button_text))
                    .fill(self.theme.button_normal)
                    .rounding(Rounding::same(5.0))
                ).clicked() {
                    self.state = AppState::About;
                }
            });
            
            ui.add_space(10.0);
            ui.separator();
            ui.add_space(10.0);
            
            // Wrap all content in a ScrollArea to enable scrolling when content exceeds window height
            egui::ScrollArea::vertical().show(ui, |ui| {
                // Display appropriate screen based on state
                match self.state {
                    AppState::Dashboard => self.show_dashboard(ui),
                    AppState::Main => self.show_main_screen(ui),
                    AppState::Encrypting => self.show_encrypt_screen(ui),
                    AppState::EncryptionWorkflow => self.show_encryption_workflow(ui),
                    AppState::Decrypting => self.show_decrypt_screen(ui),
                    AppState::KeyManagement => self.show_key_management(ui),
                    AppState::SplitKeyManagement => self.show_split_key_management(ui),
                    AppState::TransferPreparation => self.show_transfer_preparation(ui),
                    AppState::TransferReceive => self.show_transfer_receive(ui),
                    AppState::ViewLogs => self.show_logs(ui),
                    AppState::About => self.show_about(ui),
                }
            });
            
            // Status bar at the bottom
            ui.add_space(10.0);
            ui.separator();
            ui.add_space(5.0);
            
            ui.horizontal(|ui| {
                if !self.error_message.is_empty() {
                    ui.label(RichText::new(&self.error_message).color(self.theme.error));
                } else {
                    ui.label(RichText::new(&self.status_message).color(self.theme.text_secondary));
                }
                
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if self.current_key.is_some() {
                        ui.label(RichText::new("üîë Key loaded").color(self.theme.success));
                    } else {
                        ui.label(RichText::new("‚ö†Ô∏è No key loaded").color(self.theme.error));
                    }
                });
            });
        });
        
        // Request repaint if operation is in progress
        if !self.progress.lock().unwrap().is_empty() {
            ctx.request_repaint();
        }
    }
}

impl CrustyApp {
    // Select files using native file dialog
    pub fn select_files(&mut self) {
        let fd = if matches!(self.operation, FileOperation::Decrypt) {
            rfd::FileDialog::new().add_filter("Encrypted Files", &["encrypted"])
        } else {
            rfd::FileDialog::new().add_filter("All Files", &["*"])
        };

        let files = if self.batch_mode {
            fd.set_title("Select Files").pick_files()
        } else {
            fd.set_title("Select a File").pick_file().map(|file| vec![file])
        };

        if let Some(files) = files {
            if !files.is_empty() {
                self.selected_files = files;
                self.show_status(&format!("Selected {} files", self.selected_files.len()));
            }
        }
    }
    
    // Select output directory using native file dialog
    pub fn select_output_dir(&mut self) {
        if let Some(dir) = rfd::FileDialog::new()
            .set_title("Select Output Directory")
            .pick_folder() {
            self.output_dir = Some(dir);
            self.show_status(&format!("Output directory set to: {}", self.output_dir.as_ref().unwrap().display()));
        }
    }
    
    // Helper method to display error messages
    pub fn show_error(&mut self, message: &str) {
        self.error_message = message.to_string();
        // Log the error if possible
        if let Some(logger) = get_logger() {
            logger.log_error(
                "GUI",
                "application",
                &message
            ).ok();
        }
    }
    
    // Helper method to display status messages
    pub fn show_status(&mut self, message: &str) {
        self.status_message = message.to_string();
        self.error_message.clear();
    }
    
    
    // File list component UI
    fn show_file_list(&mut self, ui: &mut Ui) {
        ui.group(|ui| {
            ui.horizontal(|ui| {
                ui.heading("Recent File Operations");
                
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if !self.file_entries.is_empty() {
                        if ui.add(Button::new(RichText::new("Clear All").color(self.theme.button_text))
                            .fill(self.theme.button_normal)
                            .rounding(Rounding::same(5.0))
                        ).clicked() {
                            self.file_entries.clear();
                            self.show_status("File history cleared");
                        }
                    }
                });
            });
            
            ui.add_space(5.0);
            
            if self.file_entries.is_empty() {
                ui.label("No file operations yet");
            } else {
                // Sort entries by timestamp (newest first)
                let mut sorted_entries = self.file_entries.clone();
                sorted_entries.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
                
                let mut entry_to_remove = None;
                
                egui::ScrollArea::vertical().max_height(250.0).show(ui, |ui| {
                    for (i, entry) in sorted_entries.iter().enumerate() {
                        ui.group(|ui| {
                            ui.horizontal(|ui| {
                                // File name and operation type
                                let op_type = match entry.operation_type {
                                    FileOperationType::Encrypt => "üîí Encrypt",
                                    FileOperationType::Decrypt => "üîì Decrypt",
                                    FileOperationType::None => "‚ùì Unknown",
                                };
                                
                                ui.label(RichText::new(format!("{}: {}", op_type, entry.file_name()))
                                    .strong()
                                    .size(16.0));
                                
                                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                    // Remove button
                                    if ui.add(Button::new(RichText::new("‚ùå").color(self.theme.button_text))
                                        .fill(self.theme.error)
                                        .rounding(Rounding::same(5.0))
                                    ).clicked() {
                                        entry_to_remove = Some(i);
                                    }
                                    
                                    // Status with color
                                    ui.label(RichText::new(&entry.status_text())
                                        .color(entry.status_color(&self.theme)));
                                    
                                    // Timestamp
                                    ui.label(RichText::new(&entry.elapsed_text())
                                        .color(self.theme.text_secondary)
                                        .italics());
                                });
                            });
                            
                            ui.add_space(2.0);
                            
                            // Full path
                            ui.label(RichText::new(format!("Path: {}", entry.path.display()))
                                .color(self.theme.text_secondary));
                            
                            // Show progress bar for in-progress files
                            if let FileStatus::InProgress(progress) = entry.status {
                                ui.add(egui::ProgressBar::new(progress)
                                    .show_percentage()
                                    .animate(true));
                            }
                            
                            // Show result or error message
                            if let Some(result) = &entry.result {
                                ui.label(RichText::new(format!("Result: {}", result))
                                    .color(self.theme.success));
                            } else if let Some(error) = &entry.error {
                                ui.label(RichText::new(format!("Error: {}", error))
                                    .color(self.theme.error));
                            }
                        });
                        
                        ui.add_space(5.0);
                    }
                });
                
                // Handle entry removal outside the closure
                if let Some(idx) = entry_to_remove {
                    // Find the actual index in the original vector
                    if idx < sorted_entries.len() {
                        let entry_to_remove = &sorted_entries[idx];
                        if let Some(pos) = self.file_entries.iter().position(|e| 
                            e.path == entry_to_remove.path && 
                            e.timestamp == entry_to_remove.timestamp) {
                            self.file_entries.remove(pos);
                            self.show_status("File entry removed");
                        }
                    }
                }
            }
        });
    }
    
    // Main screen UI
    fn show_main_screen(&mut self, ui: &mut Ui) {
        ui.vertical_centered(|ui| {
            ui.add_space(20.0);
            
            // Operation mode selection
            ui.group(|ui| {
                ui.heading("Operation Mode");
                
                ui.horizontal(|ui| {
                    ui.label("Processing Mode:");
                    ui.radio_value(&mut self.batch_mode, false, "Single File");
                    ui.radio_value(&mut self.batch_mode, true, "Multiple Files");
                });
                
                ui.add_space(10.0);
                
                // File selection section
                ui.horizontal(|ui| {
                    let select_text = if self.batch_mode {
                        "Select Files"
                    } else {
                        "Select File"
                    };
                    
                    if ui.add_sized(
                        [150.0, 30.0],
                        Button::new(RichText::new(select_text).color(self.theme.button_text))
                            .fill(self.theme.button_normal)
                            .rounding(Rounding::same(8.0))
                    ).clicked() {
                        self.select_files();
                    }
                    
                    if ui.add_sized(
                        [150.0, 30.0], 
                        Button::new(RichText::new("Select Output Directory").color(self.theme.button_text))
                            .fill(self.theme.button_normal)
                            .rounding(Rounding::same(8.0))
                    ).clicked() {
                        self.select_output_dir();
                    }
                });
            });
            
            ui.add_space(10.0);
            
            // Display selected files
            if !self.selected_files.is_empty() {
                ui.group(|ui| {
                    ui.heading("Selected Files");
                    
                    let mut file_to_remove = None;
                    
                    egui::ScrollArea::vertical().max_height(150.0).show(ui, |ui| {
                        for (i, file) in self.selected_files.iter().enumerate() {
                            ui.horizontal(|ui| {
                                ui.label(format!("{}. {}", i + 1, file.file_name().unwrap_or_default().to_string_lossy()));
                                
                                if ui.add(Button::new(RichText::new("‚ùå").color(self.theme.button_text))
                                    .fill(self.theme.error)
                                    .rounding(Rounding::same(5.0))
                                ).clicked() {
                                    file_to_remove = Some(i);
                                }
                            });
                        }
                    });
                    
                    // Handle file removal outside the closure
                    if let Some(idx) = file_to_remove {
                        self.selected_files.remove(idx);
                        if self.selected_files.is_empty() {
                            self.show_status("All files removed");
                        } else {
                            self.show_status(&format!("Removed file, {} remaining", self.selected_files.len()));
                        }
                    }
                    
                    ui.add_space(5.0);
                    ui.horizontal(|ui| {
                        ui.label(format!("Total: {} file(s)", self.selected_files.len()));
                        
                        if ui.add(Button::new(RichText::new("Clear All").color(self.theme.button_text))
                            .fill(self.theme.button_normal)
                            .rounding(Rounding::same(5.0))
                        ).clicked() {
                            self.selected_files.clear();
                            self.show_status("All files cleared");
                        }
                    });
                });
            }
            
            // Display output directory
            if let Some(dir) = &self.output_dir {
                ui.group(|ui| {
                    ui.heading("Output Directory");
                    ui.label(format!("{}", dir.display()));
                });
            }
            
            ui.add_space(20.0);
            
            // Key selection - IMPROVED VERSION
            ui.group(|ui| {
                ui.heading("Encryption Key");
                
                if self.saved_keys.is_empty() {
                    ui.label("No keys available. Please create a key.");
                    
                    if ui.add_sized(
                        [150.0, 30.0],
                        Button::new(RichText::new("Create New Key").color(self.theme.button_text))
                            .fill(self.theme.button_normal)
                            .rounding(Rounding::same(8.0))
                    ).clicked() {
                        // Show a popup for key creation instead of navigating away
                        self.new_key_name = "New Key".to_string();
                        let key = EncryptionKey::generate();
                        self.saved_keys.push((self.new_key_name.clone(), key.clone()));
                        self.current_key = Some(key);
                        self.show_status(&format!("New key '{}' generated and selected", self.new_key_name));
                        self.new_key_name.clear();
                    }
                    
                    if ui.add_sized(
                        [150.0, 30.0],
                        Button::new(RichText::new("Load Key from File").color(self.theme.button_text))
                            .fill(self.theme.button_normal)
                            .rounding(Rounding::same(8.0))
                    ).clicked() {
                        self.load_key_from_file();
                    }
                } else {
                    // Display current key with visual emphasis
                    let current_key_name = self.current_key.as_ref().map_or_else(
                        || "No key selected".to_string(),
                        |current_key| {
                            self.saved_keys.iter()
                                .find_map(|(name, key)| {
                                    if key.to_base64() == current_key.to_base64() {
                                        Some(name.clone())
                                    } else {
                                        None
                                    }
                                })
                                .unwrap_or_else(|| "Unknown key".to_string())
                        }
                    );
                    
                    // Display current key with visual emphasis
                    ui.horizontal(|ui| {
                        ui.label("Current Key:");
                        ui.add_sized(
                            [200.0, 24.0],
                            egui::Label::new(
                                RichText::new(&current_key_name)
                                    .color(if self.current_key.is_some() { self.theme.success } else { self.theme.error })
                                    .strong()
                            )
                        );
                    });
                    
                    ui.add_space(5.0);
                    
                    // Dropdown for key selection - fixed to avoid borrowing issues
                    let mut selected_key_index = None;
                    
                    // Create a temporary vector of key names for the dropdown
                    let key_names: Vec<String> = self.saved_keys.iter()
                        .map(|(name, _)| name.clone())
                        .collect();
                    
                    egui::ComboBox::from_label("Select Key")
                        .selected_text(&current_key_name)
                        .width(250.0)
                        .show_ui(ui, |ui| {
                            for (i, name) in key_
